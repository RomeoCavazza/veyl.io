name: CI/CD Pipeline

# Testing Railway deployment with new Project Token

permissions:
  contents: read
  deployments: write
  actions: read

on:
  push:
    branches: [main]
    # Only deploy on main branch, and only if source code changes
    # Using paths (not paths-ignore) to explicitly include only relevant files
    paths:
      - 'apps/frontend/**'
      - 'apps/backend/**'
      - '.github/workflows/**'
      - 'package.json'
      - 'pnpm-lock.yaml'
      - 'requirements.txt'
      - 'Dockerfile'
      - 'start.sh'
  pull_request:
    branches: [main]
    paths:
      - 'apps/frontend/**'
      - 'apps/backend/**'
  # Allow manual deployment via workflow_dispatch
  workflow_dispatch:

jobs:
  # Nettoyer TOUS les anciens d√©ploiements avant de cr√©er les nouveaux
  cleanup-deployments:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      deployments: write
    steps:
      - name: Cleanup all old deployments
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              console.log('üßπ Nettoyage de tous les anciens d√©ploiements...');
              
              // R√©cup√©rer TOUS les d√©ploiements (tous environnements)
              const allDeployments = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              
              console.log(`üì¶ ${allDeployments.data.length} d√©ploiement(s) trouv√©(s) au total`);
              
              // Supprimer TOUS les anciens d√©ploiements avant de cr√©er les nouveaux
              // On va cr√©er 2 nouveaux d√©ploiements (1 Production + 1 Railway), donc on supprime tout
              console.log(`üóëÔ∏è  Suppression de TOUS les ${allDeployments.data.length} ancien(s) d√©ploiement(s) avant de cr√©er les nouveaux`);
              
              for (const deployment of allDeployments.data) {
                try {
                  // Marquer comme inactive avant de supprimer
                  await github.rest.repos.createDeploymentStatus({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    deployment_id: deployment.id,
                    state: 'inactive'
                  });
                  await github.rest.repos.deleteDeployment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    deployment_id: deployment.id
                  });
                  console.log(`üóëÔ∏è  D√©ploiement #${deployment.id} (${deployment.environment}) supprim√©`);
                } catch (error) {
                  console.log(`‚ö†Ô∏è  Erreur lors de la suppression du d√©ploiement #${deployment.id}: ${error.message}`);
                }
              }
              
              console.log('‚úÖ Tous les anciens d√©ploiements supprim√©s - les nouveaux seront cr√©√©s par les jobs frontend/backend');
              
              console.log('‚úÖ Nettoyage termin√©');
            } catch (error) {
              console.error('‚ùå Erreur lors du nettoyage:', error.message);
              // Ne pas faire √©chouer le workflow si le nettoyage √©choue
            }

  # Check if deployment is needed
  check-changes:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            frontend:
              - 'apps/frontend/**'
            backend:
              - 'apps/backend/**'
              - 'start.sh'
              - 'Dockerfile'
              - 'requirements.txt'

  frontend:
    runs-on: ubuntu-latest
    needs: [check-changes, cleanup-deployments]
    if: always() && github.ref == 'refs/heads/main'
    outputs:
      vercel-deploy-outcome: ${{ steps.vercel-deploy.outcome }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
      
      - name: Install dependencies
        working-directory: ./apps/frontend
        run: pnpm install --frozen-lockfile
        
      - name: Type check
        working-directory: ./apps/frontend
        run: pnpm type-check
        
      - name: Build
        working-directory: ./apps/frontend
        run: pnpm build
        id: build
        
      - name: Deploy to Vercel (production only)
        if: github.ref == 'refs/heads/main'
        id: vercel-deploy
        run: |
          echo "üì¶ Current directory: $(pwd)"
          echo "üì¶ Listing apps/frontend:"
          ls -la apps/frontend/ | head -20
          echo "üì¶ Checking if dist folder exists:"
          ls -la apps/frontend/dist/ 2>/dev/null || echo "‚ö†Ô∏è dist folder not found!"
          echo "üì¶ Deploying to Vercel..."
          npx -y vercel@latest --prod --token ${{ secrets.VERCEL_TOKEN }} --yes
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
      
      - name: Create GitHub Deployment (Vercel)
        if: github.ref == 'refs/heads/main'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              // V√©rifier si le d√©ploiement Vercel a r√©ussi
              const vercelOutcome = '${{ steps.vercel-deploy.outcome }}';
              const vercelSuccess = vercelOutcome === 'success';
              const deployState = vercelSuccess ? 'success' : (vercelOutcome === 'failure' ? 'failure' : 'pending');
              
              console.log(`üîç √âtat du d√©ploiement Vercel: ${vercelOutcome || 'not executed'}`);
              console.log(`üì¶ Cr√©ation du GitHub Deployment avec statut: ${deployState}`);
              
              // Le nettoyage a d√©j√† √©t√© fait par le job cleanup-deployments
              // Cr√©er directement le nouveau d√©ploiement
              console.log('‚ú® Cr√©ation du nouveau d√©ploiement Production...');
              const newDeployment = await github.rest.repos.createDeployment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.sha,
                environment: 'Production',
                auto_merge: false,
                required_contexts: [],
                description: `Deployed via GitHub Actions - ${context.sha.substring(0, 7)}`
              });
              
              console.log(`‚úÖ D√©ploiement #${newDeployment.data.id} cr√©√© avec succ√®s`);
              
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: newDeployment.data.id,
                state: deployState,
                environment_url: 'https://www.veyl.io',
                description: vercelSuccess ? 'Deployment successful' : (vercelOutcome === 'failure' ? 'Deployment failed' : 'Deployment in progress')
              });
              
              console.log(`üéâ Statut de d√©ploiement mis √† jour: ${deployState}`);
            } catch (error) {
              console.error('‚ùå Erreur lors de la cr√©ation du GitHub Deployment:', error);
              console.error('D√©tails:', JSON.stringify(error, null, 2));
              throw error;
            }

  backend:
    runs-on: ubuntu-latest
    needs: [check-changes, cleanup-deployments]
    if: always() && github.ref == 'refs/heads/main'
    outputs:
      railway-deploy-outcome: ${{ steps.railway-deploy.outcome }}
    defaults:
      run:
        working-directory: ./apps/backend
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          
      - name: Install dependencies
        run: pip install -r requirements.txt
        
      - name: Run tests (if available)
        continue-on-error: true
        run: |
          if [ -f "test_*.py" ] || [ -d "tests" ]; then
            python -m pytest || echo "Tests failed, continuing..."
          else
            echo "No tests found, skipping..."
          fi
          
      - name: Deploy to Railway (production only)
        if: github.ref == 'refs/heads/main'
        id: railway-deploy
        continue-on-error: true
        run: |
          # Railway CLI utilise RAILWAY_TOKEN depuis la variable d'environnement
          echo "üì¶ Current directory: $(pwd)"
          echo "üì¶ Deploying to Railway..."
          # Railway.toml est √† la racine, donc on d√©ploie depuis la racine
          cd ${{ github.workspace }}
          echo "üì¶ Working directory: $(pwd)"
          echo "üì¶ Checking railway.toml:"
          cat railway.toml || echo "‚ö†Ô∏è railway.toml not found"
          # Utiliser railway up sans --path-as-root car railway.toml d√©finit d√©j√† le buildPath
          npx -y @railway/cli@latest up --service veyl.io --detach && {
            echo "‚úÖ D√©ploiement r√©ussi avec service 'veyl.io'"
            exit 0
          }
          echo "‚ùå Railway CLI failed. Check if RAILWAY_TOKEN is un Project Token valide."
          exit 1
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
      
      - name: Create GitHub Deployment (Railway)
        if: github.ref == 'refs/heads/main'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const envName = 'veyl.io (veyl-production / production)';
              const railwayOutcome = '${{ steps.railway-deploy.outcome }}';
              const railwaySuccess = railwayOutcome === 'success';
              const deployState = railwaySuccess ? 'success' : (railwayOutcome === 'failure' ? 'failure' : 'pending');
              
              console.log(`üîç √âtat du d√©ploiement Railway: ${railwayOutcome || 'not executed'}`);
              console.log(`üì¶ Cr√©ation du GitHub Deployment avec statut: ${deployState}`);
              
              // Le nettoyage a d√©j√† √©t√© fait par le job cleanup-deployments
              // Cr√©er directement le nouveau d√©ploiement
              console.log(`‚ú® Cr√©ation du nouveau d√©ploiement Railway (${envName})...`);
              const newDeployment = await github.rest.repos.createDeployment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.sha,
                environment: envName,
                auto_merge: false,
                required_contexts: [],
                description: `Deployed via GitHub Actions - ${context.sha.substring(0, 7)}`
              });
              
              console.log(`‚úÖ D√©ploiement #${newDeployment.data.id} cr√©√© avec succ√®s`);
              
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: newDeployment.data.id,
                state: deployState,
                environment_url: 'https://api.veyl.io',
                description: railwaySuccess ? 'Deployment successful' : (railwayOutcome === 'failure' ? 'Deployment failed' : 'Deployment in progress')
              });
              
              console.log(`üéâ Statut de d√©ploiement mis √† jour: ${deployState}`);
            } catch (error) {
              console.error('‚ùå Erreur lors de la cr√©ation du GitHub Deployment:', error);
              console.error('D√©tails:', JSON.stringify(error, null, 2));
              throw error;
            }

  # Job final : s'assurer que les 2 d√©ploiements existent toujours
  # Cr√©e les d√©ploiements manquants si les jobs frontend/backend ont √©t√© skipp√©s
  ensure-deployments:
    runs-on: ubuntu-latest
    needs: [check-changes, cleanup-deployments]
    if: always() && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      deployments: write
    steps:
      - name: Ensure both deployments exist
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              console.log('üîç V√©rification que les 2 d√©ploiements existent...');
              
              // V√©rifier si le d√©ploiement Production existe
              const prodDeployments = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                environment: 'Production',
                per_page: 1
              });
              
              // V√©rifier si le d√©ploiement Railway existe
              const railwayEnvName = 'veyl.io (veyl-production / production)';
              const railwayDeployments = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                environment: railwayEnvName,
                per_page: 1
              });
              
              // Cr√©er le d√©ploiement Production s'il n'existe pas
              if (prodDeployments.data.length === 0) {
                console.log('üì¶ Cr√©ation du d√©ploiement Production manquant...');
                const prodDeployment = await github.rest.repos.createDeployment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: context.sha,
                  environment: 'Production',
                  auto_merge: false,
                  required_contexts: [],
                  description: `Deployed via GitHub Actions - ${context.sha.substring(0, 7)} (no frontend changes)`
                });
                
                await github.rest.repos.createDeploymentStatus({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: prodDeployment.data.id,
                  state: 'success',
                  environment_url: 'https://www.veyl.io',
                  description: 'No frontend changes in this commit'
                });
                console.log('‚úÖ D√©ploiement Production cr√©√©');
              } else {
                console.log('‚úÖ D√©ploiement Production existe d√©j√†');
              }
              
              // Cr√©er le d√©ploiement Railway s'il n'existe pas
              if (railwayDeployments.data.length === 0) {
                console.log('üì¶ Cr√©ation du d√©ploiement Railway manquant...');
                const railwayDeployment = await github.rest.repos.createDeployment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: context.sha,
                  environment: railwayEnvName,
                  auto_merge: false,
                  required_contexts: [],
                  description: `Deployed via GitHub Actions - ${context.sha.substring(0, 7)} (no backend changes)`
                });
                
                await github.rest.repos.createDeploymentStatus({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: railwayDeployment.data.id,
                  state: 'success',
                  environment_url: 'https://api.veyl.io',
                  description: 'No backend changes in this commit'
                });
                console.log('‚úÖ D√©ploiement Railway cr√©√©');
              } else {
                console.log('‚úÖ D√©ploiement Railway existe d√©j√†');
              }
              
              console.log('üéâ V√©rification termin√©e - 2 d√©ploiements garantis');
            } catch (error) {
              console.error('‚ùå Erreur lors de la v√©rification:', error.message);
              // Ne pas faire √©chouer le workflow
            }
