name: CI/CD Pipeline

# Testing Railway deployment with new Project Token

permissions:
  contents: read
  deployments: write
  actions: read

on:
  push:
    branches: [main]
    # Only deploy on main branch, and only if source code changes
    # Using paths (not paths-ignore) to explicitly include only relevant files
    paths:
      - 'apps/frontend/**'
      - 'apps/backend/**'
      - '.github/workflows/**'
      - 'package.json'
      - 'pnpm-lock.yaml'
      - 'requirements.txt'
      - 'Dockerfile'
      - 'start.sh'
  pull_request:
    branches: [main]
    paths:
      - 'apps/frontend/**'
      - 'apps/backend/**'
  # Allow manual deployment via workflow_dispatch
  workflow_dispatch:

jobs:
  # Check if deployment is needed
  check-changes:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            frontend:
              - 'apps/frontend/**'
            backend:
              - 'apps/backend/**'
              - 'start.sh'
              - 'Dockerfile'
              - 'requirements.txt'

  frontend:
    runs-on: ubuntu-latest
    needs: check-changes
    if: needs.check-changes.steps.filter.outputs.frontend == 'true' || github.event_name == 'workflow_dispatch'
    outputs:
      vercel-deploy-outcome: ${{ steps.vercel-deploy.outcome }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
      
      - name: Install dependencies
        working-directory: ./apps/frontend
        run: pnpm install --frozen-lockfile
        
      - name: Type check
        working-directory: ./apps/frontend
        run: pnpm type-check
        
      - name: Build
        working-directory: ./apps/frontend
        run: pnpm build
        id: build
        
      - name: Deploy to Vercel (production only)
        if: github.ref == 'refs/heads/main'
        id: vercel-deploy
        run: |
          echo "üì¶ Current directory: $(pwd)"
          echo "üì¶ Listing apps/frontend:"
          ls -la apps/frontend/ | head -20
          echo "üì¶ Checking if dist folder exists:"
          ls -la apps/frontend/dist/ 2>/dev/null || echo "‚ö†Ô∏è dist folder not found!"
          echo "üì¶ Deploying to Vercel..."
          npx -y vercel@latest --prod --token ${{ secrets.VERCEL_TOKEN }} --yes
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
      
      - name: Create GitHub Deployment (Vercel)
        if: github.ref == 'refs/heads/main'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              // V√©rifier si le d√©ploiement Vercel a r√©ussi
              const vercelOutcome = '${{ steps.vercel-deploy.outcome }}';
              const vercelSuccess = vercelOutcome === 'success';
              const deployState = vercelSuccess ? 'success' : (vercelOutcome === 'failure' ? 'failure' : 'pending');
              
              console.log(`üîç √âtat du d√©ploiement Vercel: ${vercelOutcome || 'not executed'}`);
              console.log(`üì¶ Cr√©ation du GitHub Deployment avec statut: ${deployState}`);
              
              // Supprimer les anciens d√©ploiements Production pour garder seulement le dernier
              const deployments = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                environment: 'Production',
                per_page: 100
              });
              
              console.log(`üì¶ ${deployments.data.length} ancien(s) d√©ploiement(s) trouv√©(s)`);
              
              // Supprimer tous les anciens d√©ploiements (on garde seulement le nouveau)
              for (const deployment of deployments.data) {
                try {
                  await github.rest.repos.deleteDeployment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    deployment_id: deployment.id
                  });
                  console.log(`üóëÔ∏è  D√©ploiement #${deployment.id} supprim√©`);
                } catch (error) {
                  console.log(`‚ö†Ô∏è  Erreur lors de la suppression du d√©ploiement #${deployment.id}: ${error.message}`);
                }
              }
              
              // Cr√©er le nouveau d√©ploiement (le seul visible)
              console.log('‚ú® Cr√©ation du nouveau d√©ploiement Production...');
              const newDeployment = await github.rest.repos.createDeployment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.sha,
                environment: 'Production',
                auto_merge: false,
                required_contexts: [],
                description: `Deployed via GitHub Actions - ${context.sha.substring(0, 7)}`
              });
              
              console.log(`‚úÖ D√©ploiement #${newDeployment.data.id} cr√©√© avec succ√®s`);
              
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: newDeployment.data.id,
                state: deployState,
                environment_url: 'https://www.veyl.io',
                description: vercelSuccess ? 'Deployment successful' : (vercelOutcome === 'failure' ? 'Deployment failed' : 'Deployment in progress')
              });
              
              console.log(`üéâ Statut de d√©ploiement mis √† jour: ${deployState}`);
            } catch (error) {
              console.error('‚ùå Erreur lors de la cr√©ation du GitHub Deployment:', error);
              console.error('D√©tails:', JSON.stringify(error, null, 2));
              throw error;
            }

  backend:
    runs-on: ubuntu-latest
    needs: check-changes
    if: needs.check-changes.steps.filter.outputs.backend == 'true' || github.event_name == 'workflow_dispatch'
    outputs:
      railway-deploy-outcome: ${{ steps.railway-deploy.outcome }}
    defaults:
      run:
        working-directory: ./apps/backend
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          
      - name: Install dependencies
        run: pip install -r requirements.txt
        
      - name: Run tests (if available)
        run: |
          if [ -f "test_*.py" ]; then
            python -m pytest
          else
            echo "No tests found, skipping..."
          fi
          
      - name: Deploy to Railway (production only)
        if: github.ref == 'refs/heads/main'
        id: railway-deploy
        continue-on-error: true
        run: |
          # Railway CLI utilise RAILWAY_TOKEN depuis la variable d'environnement
          # Le working-directory est d√©j√† apps/backend gr√¢ce √† defaults.run
          echo "üì¶ Current directory: $(pwd)"
          echo "üì¶ Deploying to Railway..."
          # Railway CLI up avec --path-as-root pour que le r√©pertoire courant soit la racine
          # Essayer avec "insidr" d'abord (nom probable du service)
          npx -y @railway/cli up --service insidr --detach --path-as-root && {
            echo "‚úÖ D√©ploiement r√©ussi avec service 'insidr'"
            exit 0
          } || {
            echo "‚ö†Ô∏è √âchec avec 'insidr', tentative avec 'insidr-production'..."
            npx -y @railway/cli up --service insidr-production --detach --path-as-root && {
              echo "‚úÖ D√©ploiement r√©ussi avec service 'insidr-production'"
              exit 0
            } || {
              echo "‚ùå Railway CLI failed. Check if RAILWAY_TOKEN is a valid Project Token."
              exit 1
            }
          }
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
      
      - name: Create GitHub Deployment (Railway)
        if: github.ref == 'refs/heads/main'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const envName = 'insidr (satisfied-mindfulness / production)';
              const railwayOutcome = '${{ steps.railway-deploy.outcome }}';
              const railwaySuccess = railwayOutcome === 'success';
              const deployState = railwaySuccess ? 'success' : (railwayOutcome === 'failure' ? 'failure' : 'pending');
              
              console.log(`üîç √âtat du d√©ploiement Railway: ${railwayOutcome || 'not executed'}`);
              console.log(`üì¶ Cr√©ation du GitHub Deployment avec statut: ${deployState}`);
              console.log(`üîç Recherche des anciens d√©ploiements Railway (${envName})...`);
              
              // Supprimer les anciens d√©ploiements Railway pour garder seulement le dernier
              const deployments = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                environment: envName,
                per_page: 100
              });
              
              console.log(`üì¶ ${deployments.data.length} ancien(s) d√©ploiement(s) trouv√©(s)`);
              
              // Supprimer tous les anciens d√©ploiements (on garde seulement le nouveau)
              for (const deployment of deployments.data) {
                try {
                  await github.rest.repos.deleteDeployment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    deployment_id: deployment.id
                  });
                  console.log(`üóëÔ∏è  D√©ploiement #${deployment.id} supprim√©`);
                } catch (error) {
                  console.log(`‚ö†Ô∏è  Erreur lors de la suppression du d√©ploiement #${deployment.id}: ${error.message}`);
                }
              }
              
              // Cr√©er le nouveau d√©ploiement (le seul visible)
              console.log(`‚ú® Cr√©ation du nouveau d√©ploiement Railway (${envName})...`);
              const newDeployment = await github.rest.repos.createDeployment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.sha,
                environment: envName,
                auto_merge: false,
                required_contexts: [],
                description: `Deployed via GitHub Actions - ${context.sha.substring(0, 7)}`
              });
              
              console.log(`‚úÖ D√©ploiement #${newDeployment.data.id} cr√©√© avec succ√®s`);
              
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: newDeployment.data.id,
                state: deployState,
                environment_url: 'https://insidr-production.up.railway.app',
                description: railwaySuccess ? 'Deployment successful' : (railwayOutcome === 'failure' ? 'Deployment failed' : 'Deployment in progress')
              });
              
              console.log(`üéâ Statut de d√©ploiement mis √† jour: ${deployState}`);
            } catch (error) {
              console.error('‚ùå Erreur lors de la cr√©ation du GitHub Deployment:', error);
              console.error('D√©tails:', JSON.stringify(error, null, 2));
              throw error;
            }

  # Job qui d√©ploie toujours Vercel sur main, m√™me si frontend job est skipp√©
  deploy-vercel:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
      
      - name: Install dependencies
        working-directory: ./apps/frontend
        run: pnpm install --frozen-lockfile
        
      - name: Build
        working-directory: ./apps/frontend
        run: pnpm build
        id: build
      
      - name: Deploy to Vercel (production only)
        id: vercel-deploy
        run: |
          echo "üì¶ Current directory: $(pwd)"
          echo "üì¶ Listing apps/frontend:"
          ls -la apps/frontend/ | head -20
          echo "üì¶ Checking if dist folder exists:"
          ls -la apps/frontend/dist/ 2>/dev/null || echo "‚ö†Ô∏è dist folder not found!"
          echo "üì¶ Deploying to Vercel..."
          npx -y vercel@latest --prod --token ${{ secrets.VERCEL_TOKEN }} --yes
        env:
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}

  # Job qui d√©ploie toujours Railway sur main, m√™me si backend job est skipp√©
  deploy-railway:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Deploy to Railway (production only)
        id: railway-deploy
        continue-on-error: true
        run: |
          echo "üì¶ Current directory: $(pwd)"
          echo "üì¶ Listing apps/backend:"
          ls -la apps/backend/ | head -20
          echo "üì¶ Deploying to Railway via CLI..."
          
          # Railway CLI utilise RAILWAY_TOKEN depuis la variable d'environnement
          # V√©rifier que le token est bien d√©fini
          if [ -z "$RAILWAY_TOKEN" ]; then
            echo "‚ùå RAILWAY_TOKEN n'est pas d√©fini!"
            exit 1
          else
            echo "‚úÖ RAILWAY_TOKEN est d√©fini (length: ${#RAILWAY_TOKEN})"
          fi
          
          echo "üîç V√©rification de la configuration Railway..."
          echo "üîç Token check..."
          npx -y @railway/cli whoami || echo "‚ö†Ô∏è Token check failed (continuing anyway)"
          
          echo "üîç Liste des services disponibles..."
          # Essayer de lister les services pour trouver le bon nom
          echo "üîç R√©cup√©ration de la liste des services..."
          npx -y @railway/cli service list 2>&1 || echo "‚ö†Ô∏è Impossible de lister les services"
          npx -y @railway/cli status || echo "‚ö†Ô∏è Impossible d'afficher le statut"
          
          echo "üì¶ D√©ploiement vers Railway..."
          # Railway CLI doit √™tre ex√©cut√© depuis la racine du repo
          # Il y a un railway.toml √† la racine qui pointe vers apps/backend
          # Il y a plusieurs services, donc il faut sp√©cifier lequel
          # PRIORIT√â: Utiliser --path-as-root depuis apps/backend pour que Railway traite apps/backend comme racine
          echo "üì¶ Tentative 1: depuis apps/backend avec --path-as-root (meilleure solution)..."
          cd apps/backend
          # Avec --path-as-root, Railway CLI traite apps/backend comme la racine
          # Le railway.toml dans apps/backend a buildPath = "." et dockerfilePath = "Dockerfile"
          # Cela garantit que Railway trouve requirements.txt dans le bon contexte
          npx -y @railway/cli up . --service insidr --detach --path-as-root && {
            echo "‚úÖ D√©ploiement r√©ussi avec service 'insidr' (depuis apps/backend)"
            exit 0
          } || {
            echo "‚ö†Ô∏è √âchec avec --path-as-root, tentative depuis la racine avec railway.toml..."
            cd ../..
            npx -y @railway/cli up --service insidr --detach && {
              echo "‚úÖ D√©ploiement r√©ussi avec service 'insidr' (depuis racine)"
              exit 0
            } || {
              echo "‚ö†Ô∏è √âchec depuis racine, tentative avec chemin explicite apps/backend..."
              npx -y @railway/cli up apps/backend --service insidr --detach && {
                echo "‚úÖ D√©ploiement r√©ussi avec service 'insidr' (chemin explicite)"
                exit 0
              } || {
                echo "‚ùå √âchec de toutes les tentatives. V√©rifie:"
                echo "   1. RAILWAY_TOKEN est un Project Token valide"
                echo "   2. Le nom du service dans Railway (peut √™tre diff√©rent de 'insidr')"
                echo "   3. Utilise 'railway service list' pour voir les services disponibles"
                exit 1
              }
            }
          }
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}

  # Job qui s'ex√©cute toujours pour cr√©er les GitHub Deployments
  # M√™me si les jobs frontend/backend ne s'ex√©cutent pas (pour faire appara√Ætre la section)
  # Test: v√©rifier que les anciens d√©ploiements sont bien supprim√©s (devrait rester √† 2 max)
  ensure-deployments-visible:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      deployments: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Create GitHub Deployment (Vercel)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              console.log('üîç Cr√©ation du GitHub Deployment Production...');
              
              // Supprimer les anciens d√©ploiements
              const deployments = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                environment: 'Production',
                per_page: 100
              });
              
              console.log(`üì¶ ${deployments.data.length} ancien(s) d√©ploiement(s) trouv√©(s)`);
              
              for (const deployment of deployments.data) {
                try {
                  await github.rest.repos.deleteDeployment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    deployment_id: deployment.id
                  });
                  console.log(`üóëÔ∏è  D√©ploiement #${deployment.id} supprim√©`);
                } catch (error) {
                  console.log(`‚ö†Ô∏è  Erreur: ${error.message}`);
                }
              }
              
              // Cr√©er le nouveau d√©ploiement
              const newDeployment = await github.rest.repos.createDeployment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.sha,
                environment: 'Production',
                auto_merge: false,
                required_contexts: [],
                description: `Deployed via GitHub Actions - ${context.sha.substring(0, 7)}`
              });
              
              console.log(`‚úÖ D√©ploiement #${newDeployment.data.id} cr√©√©`);
              
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: newDeployment.data.id,
                state: 'success',
                environment_url: 'https://www.veyl.io'
              });
              
              console.log('üéâ D√©ploiement Production cr√©√© et visible');
            } catch (error) {
              console.error('‚ùå Erreur:', error.message);
              throw error;
            }
      
      - name: Create GitHub Deployment (Railway)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const envName = 'insidr (satisfied-mindfulness / production)';
              console.log(`üîç Cr√©ation du GitHub Deployment Railway (${envName})...`);
              
              const deployments = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                environment: envName,
                per_page: 100
              });
              
              console.log(`üì¶ ${deployments.data.length} ancien(s) d√©ploiement(s) trouv√©(s)`);
              
              for (const deployment of deployments.data) {
                try {
                  await github.rest.repos.deleteDeployment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    deployment_id: deployment.id
                  });
                  console.log(`üóëÔ∏è  D√©ploiement #${deployment.id} supprim√©`);
                } catch (error) {
                  console.log(`‚ö†Ô∏è  Erreur: ${error.message}`);
                }
              }
              
              const newDeployment = await github.rest.repos.createDeployment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.sha,
                environment: envName,
                auto_merge: false,
                required_contexts: [],
                description: `Deployed via GitHub Actions - ${context.sha.substring(0, 7)}`
              });
              
              console.log(`‚úÖ D√©ploiement #${newDeployment.data.id} cr√©√©`);
              
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: newDeployment.data.id,
                state: 'success',
                environment_url: 'https://insidr-production.up.railway.app'
              });
              
              console.log('üéâ D√©ploiement Railway cr√©√© et visible');
            } catch (error) {
              console.error('‚ùå Erreur:', error.message);
              throw error;
            }
